{"version":3,"file":"index.js","sources":["../source/trimSlashes.js","../source/parse.js","../source/sortNodes.js","../source/addPath.js","../source/matchPath.js","../source/index.js"],"sourcesContent":["// Remove the first and last slash\nexport default function trimSlashes(path) {\n\tconst from = path[0] === \"/\" ? 1 : undefined;\n\tconst to = path[path.length - 1] === \"/\" ? -1 : undefined;\n\n\treturn path.slice(from, to);\n}\n","import trimSlashes from \"./trimSlashes.js\";\n\nconst characters = \"[\\\\w\\\\!\\\\$&'\\\\(\\\\)\\\\*\\\\+\\\\,;\\\\=\\\\:@\\\\-\\\\.~]\";\nconst encoded = \"%[A-F0-9]{2}\";\n\nconst wildcard = \"(\\\\*)\";\nconst optional = \"(\\\\?)?\";\nconst key = \"(\\\\w+)\";\n\n// {key} {key?} {key*}, {key*2}\nconst param = `\\\\{${key}(?:${wildcard})?${optional}\\\\}`;\nconst literal = `(?:${characters}|${encoded})+`;\nconst segment = `(${literal})|(?:${param})`;\n\nconst regex = new RegExp(segment, \"g\");\n\nexport default path => {\n\tconst segments = [];\n\n\ttrimSlashes(path).replace(regex, setSegment);\n\n\tfunction setSegment(segment, literal, key, wildcard, optional) {\n\t\tsegments.push({\n\t\t\tsegment,\n\t\t\tliteral,\n\t\t\tkey,\n\t\t\tisOptional: Boolean(optional),\n\t\t\tisWildcard: Boolean(wildcard)\n\t\t});\n\t}\n\n\treturn segments;\n};\n","/*\n  Sort nodes in array to prioritize matching:\n\n  1. literal\n  2. {key}  - param\n  3. {key*} - wildcard\n  4. {key?} - optional\n*/\nexport default (A, B) => {\n\tconst AFirst = -1;\n\tconst BFirst = 1;\n\n\t// one is a literal, or both\n\tif (!A.key || !B.key) {\n\t\treturn !A.key ? AFirst : BFirst;\n\t}\n\n\t// both wildcards? can't do\n\tif (A.wildcard && B.wildcard) {\n\t\tthrow new Error(`Route conflict wildcards: ${A.segment} ${B.segment}`);\n\t}\n\n\t// one is a wildcard\n\tif (A.wildcard || B.wildcard) {\n\t\treturn A.wildcard ? BFirst : AFirst;\n\t}\n};\n","import parse from \"./parse.js\";\nimport sortNodes from \"./sortNodes.js\";\n\nexport default function addPath(path, data, target) {\n\tconst segments = parse(path);\n\n\t// set each segment on its branch\n\tbranching: for (let n = 0, branch = target; n < segments.length; ++n) {\n\t\tconst isLastSegment = n === segments.length - 1;\n\t\tconst node = segments[n];\n\n\t\t// add children for branching\n\t\tnode.children = [];\n\t\tnode.literal = node.literal && node.literal.toLowerCase();\n\n\t\t// check if segment is already defined\n\t\tfor (let i = 0; i < branch.children.length; ++i) {\n\t\t\tconst child = branch.children[i];\n\n\t\t\tif (child.segment === node.segment) {\n\t\t\t\tif (isLastSegment) {\n\t\t\t\t\tif (child.data) {\n\t\t\t\t\t\tthrow new Error(`Path conflict: ${path} segment: ${node.segment}`);\n\t\t\t\t\t}\n\n\t\t\t\t\tchild.data = data;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbranch = child;\n\t\t\t\tcontinue branching;\n\t\t\t}\n\t\t}\n\n\t\t// if segment is optional add the\n\t\t// data on the parent also\n\t\tif (node.isOptional && isLastSegment) {\n\t\t\tif (branch.data != null) {\n\t\t\t\tthrow new Error(`Path conflict: ${path} segment: ${node.segment}`);\n\t\t\t}\n\n\t\t\tbranch.data = data;\n\t\t}\n\n\t\t// add data on last segment\n\t\tif (isLastSegment) {\n\t\t\tnode.data = data;\n\t\t}\n\n\t\t// add node to branch\n\t\tbranch.children.push(node);\n\n\t\t// sort child nodes for match type priority\n\t\tbranch.children.sort(sortNodes);\n\n\t\t// the child becomes the parent for the next segment\n\t\tbranch = node;\n\t}\n}\n","import trimSlashes from \"./trimSlashes.js\";\n\nexport default function matchPath(path, root) {\n\tconst segments = trimSlashes(path).split(\"/\");\n\tconst last = segments.length - 1;\n\tconst params = {};\n\n\tlet unmatched = null;\n\tlet branch = root;\n\n\tmatch: for (let n = 0; n < segments.length; ++n) {\n\t\tconst segment = segments[n];\n\n\t\tfor (let i = 0; i < branch.children.length; ++i) {\n\t\t\tconst node = branch.children[i];\n\n\t\t\t// match literal\n\t\t\tif (!node.key && node.literal === segment.toLowerCase()) {\n\t\t\t\tbranch = node;\n\t\t\t\tcontinue match;\n\t\t\t}\n\n\t\t\t// {key}\n\t\t\tif (node.key && !node.isWildcard) {\n\t\t\t\tparams[node.key] = segment;\n\t\t\t\tbranch = node;\n\t\t\t\tcontinue match;\n\t\t\t}\n\n\t\t\t// {key*}\n\t\t\tif (node.isWildcard) {\n\t\t\t\tparams[node.key] = segments.splice(n, last);\n\t\t\t\tbranch = node;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// if no node is matched, store the rest of the segments\n\t\tunmatched = segments.slice(n, segments.length).join(\"/\");\n\n\t\tbreak;\n\t}\n\n\t// mark null if no node is matched\n\tconst match = branch === root ? null : branch;\n\n\treturn { params, unmatched, node: match };\n}\n","import addPath from \"./addPath.js\";\nimport matchPath from \"./matchPath.js\";\n\nexport { addPath, matchPath };\n\nexport default class Router {\n\tconstructor(options = {}) {\n\t\tconst { routes } = options;\n\n\t\tthis.root = {\n\t\t\tsegment: \"/\",\n\t\t\tchildren: [],\n\t\t\tdata: null\n\t\t};\n\n\t\tif (routes) {\n\t\t\tfor (const { path, data } of routes) {\n\t\t\t\tthis.set(path, data);\n\t\t\t}\n\t\t}\n\t}\n\n\tset(path, data) {\n\t\tif (path === \"/\") {\n\t\t\tif (this.root.data) {\n\t\t\t\tthrow new Error(`Route \"/\" already set.`);\n\t\t\t}\n\n\t\t\tthis.root.data = data;\n\t\t} else {\n\t\t\taddPath(path, data, this.root);\n\t\t}\n\t}\n\n\tget(path) {\n\t\tif (path === \"/\") return this.root;\n\n\t\tconst { node } = matchPath(path, this.root);\n\n\t\treturn this.root === node ? null : node;\n\t}\n\n\tmatch(path) {\n\t\tif (path === \"/\") {\n\t\t\treturn {\n\t\t\t\tparams: {},\n\t\t\t\tdata: this.root.data,\n\t\t\t\tunmatched: null\n\t\t\t};\n\t\t} else {\n\t\t\tconst match = matchPath(path, this.root);\n\n\t\t\treturn {\n\t\t\t\tparams: match.params,\n\t\t\t\tunmatched: match.unmatched,\n\t\t\t\tdata: match.node ? match.node.data : null\n\t\t\t};\n\t\t}\n\t}\n}\n"],"names":["trimSlashes","path","slice","undefined","length","const","regex","RegExp","A","B","key","wildcard","Error","addPath","data","target","segments","replace","segment","literal","optional","push","isOptional","Boolean","isWildcard","parse","branching","let","n","branch","isLastSegment","node","children","toLowerCase","i","child","sort","sortNodes","matchPath","root","split","last","params","unmatched","match","splice","join","Router","options","routes","ref","set","this","get"],"mappings":"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"}